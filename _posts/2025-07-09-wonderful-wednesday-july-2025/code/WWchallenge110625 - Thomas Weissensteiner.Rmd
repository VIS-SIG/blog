---
title: "Hyperkalemia Trial"
author: "Thomas Weissensteiner"
date: "2025-02-07"
output:
  html_document:
    code_folding: show
    toc: true
    toc_float: true
    toc_depth: 4
---
HTML version and code updates: [Rpubs/thomas-weissensteiner](https://rpubs.com/thomas-weissensteiner)  


```{r Options, include = FALSE}
# - Global directory and output options                         - # 

# The working directory in "Global directory and output options" needs to be customised, and should include the following additional files:
# "variants_simulated.csv", the example data file
# "Summarizing_Human_Phenotype_Ontology_Terms_figs", a folder containing additional figures not generated by the code chunks  

knitr::opts_knit$set(root.dir = "C:/Users/ThomasWeissensteiner/OneDrive/Documents/portfolio/WWchallenges/WWchallenge_58")
knitr::opts_chunk$set (warning = FALSE, message = FALSE, tidy = FALSE)
knitr::opts_chunk$set (attr.output='style="max-height: 200px"')

setwd("C:/Users/ThomasWeissensteiner/OneDrive/Documents/portfolio/WWchallenges/WWchallenge_61")

```


```{r libraries_and_data}
# - chunk libraries_and_data

## Load R libraries and the data file                             - #

library(dplyr)        # version 1.1.4  # general grammar
library(tidyr)        # version 1.3.1  # pivot_longer, pivot_wider
library(ggplot2)      # version 3.4.0  # graphs

HyKal_simData <- read.csv("https://raw.githubusercontent.com/VIS-SIG/Wonderful-Wednesdays/refs/heads/master/data/2025/2025-06-11/serum_potassium_study_data.csv")
```
<br>
<br>

### 1. Background
<br>

A trial was recently published comparing sodium zirconium cyclosilicate versus sodium polystyrene sulfonate for treatment of hyperkalemia in hemodialysis patients.^1^ 
The primary results were presented as a single figure showing mean serum potassium concentrations over time for the for each treatment group:

```{r, echo=FALSE, out.width="50%", out.heigh = "50%", fig.align = "center"}
knitr::include_graphics("https://cdn.ncbi.nlm.nih.gov/pmc/blobs/7f39/12054224/4012eb4e6c74/12882_2025_4129_Fig2_HTML.jpg")
```

The preceding [PSI "Wonderful Wednesday" challenge](https://psiweb.org/sigs-special-interest-groups/visualisation/welcome-to-wonderful-wednesdays) invited improvements for this figure. In this follow-up, the task was to generate a plot that made use of patient level information. Because only the publication reported only summary data, the organizers of the challenge provided a simulated data-set.  

In normal conditions, serum K+ is constantly maintained within normal ranges (4.0–4.9 mEq/L).^2^  
Hyperkalemia is defined as a serum or plasma potassium level above the upper limits of normal, usually greater than 5.0 mEq/L to 5.5 mEq/L. While mild hyperkalemia is usually asymptomatic, high potassium levels may cause life-threatening cardiac arrhythmias, muscle weakness, or paralysis. Symptoms usually develop at higher levels, 6.5 mEq/L to 7 mEq/L, but the rate of change is more important than the numerical value. Patients with chronic hyperkalemia may be asymptomatic at increased levels, while patients with dramatic, acute potassium shifts may develop severe symptoms at lower ones.^3^  

Major risk factors for hyperkalemia among CKD patients include lower estimated glomerular filtration rate (eGFR), use of renin–angiotensin–aldosterone system inhibitors (RAASis), diabetes, older age and male gender.^4^
<br>
<br>

### 2. Raw data
<br>

```{r chunk_1, fig.dim = c(10, 5)}
# Required: R libraries, HyKal_simData (chunk libraries_and_data)


## Individual patient responses vs. week of treatment

# Normal serum K[+] as defined in reference 2
normokalemia <- c(4, 4.9)

# K_threshold is set based on results in chunk 3
K_threshold <- 5.3

HyKal_simData %>%
  # Add a column showing whether baseline levels were below or above K_threshold
  mutate(
    K_base = case_when(
      Serum_Potassium_mEq_L <= K_threshold & Time_Point == "Baseline" 
        ~ paste0(Group, ".K_low"), 
      Serum_Potassium_mEq_L > K_threshold & Time_Point == "Baseline" 
        ~ paste0(Group, ".K_high"),
      .default = NA_character_
      ) %>% factor()
    ) %>% 
  group_by(Patient_ID) %>%
  fill(K_base, .direction = "downup") %>% 
  # Add a column showing whether serum K[+] levels were normal at any time during treatment
  mutate(
    normal = ifelse(
      between(Serum_Potassium_mEq_L, min(normokalemia), max(normokalemia)), 
      Week, NA),
    normal = if (all(is.na(normal[-1]))) "No" else "Yes",
    color = paste(K_base, normal, sep = "_") %>% factor()
    ) %>%
  ungroup() %>%

  ggplot(
    aes(
      x = Week, 
      y = Serum_Potassium_mEq_L,
      group = Patient_ID,
      color = color,
      size = K_base
      )
    ) +
  geom_ribbon(
    inherit.aes = FALSE,
    aes(
      x = Week,
      ymin = min(normokalemia), 
      ymax = max(normokalemia)),
      fill = "lightgrey",
      alpha = 0.7
      ) +
  geom_line() +
  annotate(
    "text", 
    label = "Normal range",
    size = 3,
    x = 0.3, 
    y = range(normokalemia) %>% sum()/2,
    angle = 90  
    ) +
  scale_color_manual(values = c("darkred", "#F8766D", "blue", "darkblue", "#00BFC4", "darkcyan")) +
  scale_size_manual(values = c(0.7 ,1.4 , 0.7, 1.4) ) +
  scale_y_continuous(
    breaks = c(4:6, K_threshold),
    minor_breaks = NULL,
    ) +
  facet_wrap(.~Group) +
  labs(
    title = "Serum potassium levels vs. week of treatment in individual patients receiving SPS or SZC",
    y = "Serum K[+] (mEq/L)",
    caption = paste("Darker and thicker lines represent patients with a baseline serum K[+] below the", K_threshold, "mEq/L threshold. \nBlue lines are serum K[+] concentrations in patients who never achieved normokalemia. See the following figures for an explanation.")
    ) +
  theme_light() +
  theme(
    plot.title = element_text(hjust = 0.5),
    strip.background = element_blank(),
    strip.text.x = element_text(
      color = "black",
      size = 11
      ),
    plot.caption = element_text(hjust = 0, size = 8),
    legend.position = "none"
    ) 

```
<br>
<br>

### 3. Outcome 1: rate of serum K[+] change
<br>

#### 3.1. Rate of serum K[+] change vs. numerical baseline patient characteristics
<br>

```{r chunk_2, fig.dim = c(7.5, 7.5)}
# - Required: R libraries, HyKal_simData (chunk libraries_and_data)


## Rate of serum K[+] change vs. numerical baseline patient characteristics

# Calculate treatments response rates (change in serum K[+] per week, fitted as a linear model)

HyKal_simData_rate <- 
  HyKal_simData %>%
    group_by(Patient_ID) %>%
    summarise(
        Rate = coef(lm(Week ~ Serum_Potassium_mEq_L))[2], 
        .groups = "drop"
    ) %>% 
    right_join(HyKal_simData, by = "Patient_ID") %>% 
    filter(Time_Point == "Baseline") %>% 
    select(
    Group,
    Age, Gender, 
    Baseline_eGFR, Serum_Potassium_mEq_L,
    Diabetes, Hypertension,
    Rate
)


# Function for plotting outcomes vs. numerical baseline variables 
# This codes uses the facet strip text as a workaround for generating individual x-axis titles for each facet

quantBase_dotPlot <- function(data, outcome, label_nudge, label_offset) {
    
    outcome <- sym(outcome)
    
# Reformat input data-frame

  data_long <- 
    data %>%
      rename(
        "Age (years)" = Age,
        "Baseline eGFR (ml/min/1.73m^2)" = Baseline_eGFR,
        "Baseline serum K[+] (mEq/L)" = Serum_Potassium_mEq_L) %>% 
      pivot_longer(
        cols = !c(Group, Gender, Diabetes, Hypertension, !!outcome),
        names_to = "variables"
        )

    # Labelled horizontal lines for SPS and SZC group medians
    median_labels_rates <- 
        left_join(
            # Group median values
            data_long %>%
                group_by(variables, Group) %>%
                summarise(median_outcome = median(!!outcome), .groups = "drop"),
            # x-limits for label positioning
            data_long %>%
                group_by(variables) %>%
                summarise(x_pos = max(value, na.rm = TRUE), .groups = "drop")
        ) %>% 
        # y-values for label positioning, with +/- nudging from median line
        mutate(
            y_pos = median_outcome + 
                ((as.factor(median_outcome) %>% as.numeric)*label_nudge - label_offset)
        )
    
    data_long %>% 
        ggplot(
            aes(
                x = value,
                y = !!outcome,
                color = Group
            )
        ) +
        geom_point() +
        geom_hline(
            data = median_labels_rates,
            aes(yintercept = median_outcome, color = Group),
            linetype = "dotted",
            linewidth = 0.8
        ) +
        geom_quantile(quantiles = 0.5) +
        geom_text(
            data = median_labels_rates,
            aes(
                x = x_pos, y = y_pos, 
                label = paste(Group, "\nmedian regression"),
                color = Group
            ),
            fontface = "bold",
            hjust = 0.65, 
            size = 3
        ) +
        facet_wrap(
            .~variables,
            scales = "free_x",
            strip.position = "bottom",
            nrow = 3
        ) +
        theme_minimal() +
        theme(
            strip.placement = "outside",
            axis.title.x = element_blank(),
            plot.title = element_text(hjust = 0.5),
            plot.caption = element_text(hjust = 0, size = 8),
            legend.position = "none"
        )
}


# Plot rate of K[+] level change vs. numerical baseline variables 

quantBase_dotPlot(HyKal_simData_rate, "Rate", 6, 9) +
    labs(
      title = "Rate of serum potassium change vs. numerical baseline characteristics",
      x ="",
      y = bquote("Serum K[+] change (" ~ Delta ~ "mEq /L /Week)"),
      caption = "Treatment response rates are unrelated to age or baseline estimated glomerular filtration rate (eGFR), median regression lines differ minimally \nfrom the overall median (dotted lines). \nBaseline serum K[+] levels appear to be negatively associated with response rate variance. \nWeak trends appear to exist for a decline of rates with increasing K[+] levels in SPS-treated patients, and an increase in patients treated with SZC."
    ) 

```
<br>

#### 3.2. Rate of serum K[+] change vs. selected categorical baseline patient characteristics
<br>

```{r geom_splitViolin}
## Functions for generating split violin plots and custom labels for the violin halves

# Custom ggproto object for generating split violin plots
# Source: https://stackoverflow.com/questions/35717353/split-violin-plot-with-ggplot2

GeomSplitViolin <- ggplot2::ggproto(
    "GeomSplitViolin",
    ggplot2::GeomViolin,
    draw_group = function(self,
                          data,
                          ...,
                          # add the nudge here
                          nudge = 0,
                          draw_quantiles = NULL) {
        data <- transform(data,
                          xminv = x - violinwidth * (x - xmin),
                          xmaxv = x + violinwidth * (xmax - x))
        grp <- data[1, "group"]
        newdata <- plyr::arrange(transform(data,
                                           x = if (grp %% 2 == 1) xminv else xmaxv),
                                 if (grp %% 2 == 1) y else -y)
        newdata <- rbind(newdata[1, ],
                         newdata,
                         newdata[nrow(newdata), ],
                         newdata[1, ])
        newdata[c(1, nrow(newdata)-1, nrow(newdata)), "x"] <- round(newdata[1, "x"])

        # now nudge them apart
        newdata$x <- ifelse(newdata$group %% 2 == 1,
                            newdata$x - nudge,
                            newdata$x + nudge)

        if (length(draw_quantiles) > 0 & !scales::zero_range(range(data$y))) {

            stopifnot(all(draw_quantiles >= 0), all(draw_quantiles <= 1))

            quantiles <- ggplot2:::create_quantile_segment_frame(data,
                                                             draw_quantiles)
            aesthetics <- data[rep(1, nrow(quantiles)),
                               setdiff(names(data), c("x", "y")),
                               drop = FALSE]
            aesthetics$alpha <- rep(1, nrow(quantiles))
            both <- cbind(quantiles, aesthetics)
            quantile_grob <- ggplot2::GeomPath$draw_panel(both, ...)
            ggplot2:::ggname("geom_split_violin",
                             grid::grobTree(ggplot2::GeomPolygon$draw_panel(newdata, ...),
                                            quantile_grob))
        }
    else {
            ggplot2:::ggname("geom_split_violin",
                             ggplot2::GeomPolygon$draw_panel(newdata, ...))
        }
    }
)

geom_split_violin <- function(mapping = NULL,
                              data = NULL,
                              stat = "ydensity",
                              position = "identity",
                              # nudge param here
                              nudge = 0,
                              ...,
                              draw_quantiles = NULL,
                              trim = TRUE,
                              scale = "area",
                              na.rm = FALSE,
                              show.legend = NA,
                              inherit.aes = TRUE) {

    ggplot2::layer(data = data,
                   mapping = mapping,
                   stat = stat,
                   geom = GeomSplitViolin,
                   position = position,
                   show.legend = show.legend,
                   inherit.aes = inherit.aes,
                   params = list(trim = trim,
                                 scale = scale,
                                 # don't forget the nudge
                                 nudge = nudge,
                                 draw_quantiles = draw_quantiles,
                                 na.rm = na.rm,
                                 ...))
}


##  Custom geom for split violin labels

StatSplitViolinLabels <- 
  ggproto(
    "StatSplitViolinLabels", Stat,
    required_aes = c("x", "y", "fill"
    ),
  setup_params = function(data, params) {
    params
  },
  
  # Compute panel for same y-coordinates
  compute_panel = function(data, scales, nudge_amount = 0.4, x_offset = 0, 
                          y_offset = 0, y_position_pct = 0.9, label_colour = NULL) {
    
    # Calculate y position based on OVERALL data range (not per group)
    y_max <- max(data$y)
    y_min <- min(data$y)
    y_pos <- y_min + (y_max - y_min) * y_position_pct + y_offset
    
    # Process each group separately but use the same y_pos for all
    result_list <- split(data, data$group)
    results <- lapply(result_list, function(group_data) {
      # Get the group information
      group_val <- unique(group_data$fill)
      x_val <- unique(group_data$x)
      group_num <- unique(group_data$group)
      
      # Calculate x position based on ggplot2's internal group number
      x_pos <- if(group_num %% 2 == 1) {
        x_val - nudge_amount/2 + x_offset  # Odd groups (left)
      } else {
        x_val + nudge_amount/2 + x_offset  # Even groups (right)
      }
      
      # Create result data-frame
      result <- data.frame(
        x = x_pos,
        y = y_pos,
        label = as.character(group_val),
        fill = group_val,
        group = group_num,
        stringsAsFactors = FALSE
      )
      
      # Handle colour aesthetic
      if ("colour" %in% names(group_data)) {
        # Use mapped colour aesthetic
        result$colour <- unique(group_data$colour)
      } else if (!is.null(label_colour)) {
        # Use parameter-specified colour
        result$colour <- label_colour
      }
      # If neither, let default geom aesthetic handle it
      
      return(result)
    })
    
    # Combine all results
    do.call(rbind, results)
  }
)

# Create custom Geom for the labels
GeomSplitViolinLabels <- ggproto("GeomSplitViolinLabels", GeomText,
  default_aes = aes(colour = "black", size = 4, angle = 0, hjust = 0.5, 
                    vjust = 0.5, alpha = 1, family = "", fontface = "bold", 
                    lineheight = 1.2)
)

geom_split_violin_labels <- 
  function(
    mapping = NULL, data = NULL, 
    nudge_amount = 0.4, x_offset = 0, y_offset = 0, 
    y_position_pct = 0.9, size = 4, fontface = "bold",
    colour = NULL, color = NULL, ..., na.rm = FALSE, 
    show.legend = FALSE, inherit.aes = TRUE) {
    
      # Handle color/colour argument
      if (!is.null(color)) colour <- color
    
      # Create the layer parameters - BACK TO ORIGINAL APPROACH
      params <- list(
        nudge_amount = nudge_amount,
        x_offset = x_offset,
        y_offset = y_offset,
        y_position_pct = y_position_pct,
        size = size,
        fontface = fontface,
        na.rm = na.rm,
        label_colour = colour,  # Pass colour to stat like original
        ...
        )
    
      # Don't remove colour from params if using default
      if (!is.null(colour) && is.null(mapping)) {
        # Only remove colour from params if we have aesthetic mapping
        # Otherwise keep it for the geom
        params$colour <- colour
        params <- params[names(params) != "label_colour"]
      }
    
    layer(
      data = data,
      mapping = mapping,
      stat = StatSplitViolinLabels,
      geom = GeomSplitViolinLabels,
      position = "identity",
      show.legend = show.legend,
      inherit.aes = inherit.aes,
      params = params
      )
    }

```


```{r split_violin_plots_and_annotations}
## Functions for generating faceted split violin plots comparing outcomes across treatments and patient subgroups 
#  Required: - R libraries (chunk libraries_and_data)
#            - geom_split_violin, geom_split_violin_labels (chunk geom_splitViolin)


## Function for plotting
# Input: outcome and comparison tables derived from Hykal_simData (data, data_p), name of outcome variable ("outcome")

halfviolin_facetPlot <- function(data, outcome, data_p) {

  outcome <- sym(outcome)
  labels_yOffset <- min(data[[outcome]]) %>% abs()
  data_p <- data_p %>% 
    mutate(., labels_yOffset = labels_yOffset)
    
  data %>%

  mutate(
  K_level = ifelse(
    Serum_Potassium_mEq_L <= K_threshold, 
    "Yes", "No")
    ) %>%
  pivot_longer(
    cols = c(K_level, Diabetes, Hypertension, Gender),
    names_to = "pChar"
    ) %>% 
  mutate(
    value = factor(value, c("Yes", "No", "Male", "Female") ),
    pChar = ifelse(
      pChar == "K_level", 
      paste("Baseline K[+]", K_threshold, "mEq/mL or less"), 
      pChar
      ) %>% 
      factor,
    .keep = "unused",
    pChar = factor(pChar, levels = levels(data_p$pChar) ),
    Group = factor(Group)
    ) %>% 
  
  ggplot(
    aes(
      x = value,
      y = !!outcome,
      color = Group,
      fill = Group,
      label = Group
    )
  ) +
  geom_split_violin( 
    width = 1,
    nudge = 0.01,
    alpha = 0.3,
    color = "grey") +
  geom_boxplot(
      color = "black",
      alpha = 0,
      width = 0.3, 
      outlier.shape = NA) +
  geom_point(
    pch = 21,
    size = 3,
    position = 
      position_jitterdodge(
        dodge.width = 0.6, 
        jitter.width = 0.1
        ),
    color = "grey",
    alpha = 0.6
    ) +
  # p-value annotation for treatment comparisons
   geom_text(
    data = data_p,
    inherit.aes = FALSE,
    aes(
      label = 
       ifelse (
          p_value_1 > 0.05, "ns", 
          paste0(
            "p == ", 
            signif(p_value_1, digits = 2)
          )
        ),
      x = value,
      y = -labels_yOffset
      ), 
    parse = TRUE
    ) +
  # Brackets and p-value annotation for level comparisons
  geom_errorbarh(
        inherit.aes = FALSE,
        aes(
            color = Group,
            y = - as.numeric(Group) * 2 - labels_yOffset -1,
            xmin = as.numeric(Group)/5.75 + 0.733, 
            xmax = as.numeric(Group)/5.75 + 1.733
        )
    ) +
   geom_text(
    data = data_p,
    inherit.aes = FALSE,
    aes(
      label = 
       ifelse (
          p_value_2 > 0.05, "ns", 
          paste0(
            "p == ", 
            signif(p_value_2, digits = 2)
          )
        ),
      y = -as.numeric(Group) * 2 - labels_yOffset,
      color = Group
      ), 
    x = 1.5,
    parse = TRUE
    ) +   
  geom_split_violin_labels(nudge_amount = 0.6) +
  facet_wrap(
    .~pChar,
    scales = "free_x") + 
  theme_light () +
  theme(
    strip.background = element_rect(fill = "#f2f3f4", color = "grey"),
    strip.text = element_text(color = "black"),
    text = element_text( size = 13), 
    plot.title = element_text(
      size = 14,
      hjust = 0.5,
      vjust = 5
      ),
    axis.text = element_text(size = 12),
    plot.caption = element_text(
      hjust = 0,
      vjust = -5
    ),
    plot.margin = unit(c(0.5,0.1,0.5,0), "cm"),
    legend.position = "none"
    )
}



## Functions for generating data-frames for plot annotations

# Standalone functions for treatment comparisons (SPS vs SZC)

treatment_comparisons <- function(data, outcome) {
  data %>%
    group_by(pChar, value) %>%
    summarise(
      p_value_1 = tryCatch({
        # Use string column name to extract values
        sps_values <- .data[[outcome]][Group == "SPS"]
        szc_values <- .data[[outcome]][Group == "SZC"]
        wilcox.test(sps_values, szc_values)$p.value
        },
        error = function(e) NA_real_
        ),
      n_SPS = sum(Group == "SPS"),
      n_SZC = sum(Group == "SZC"),
      .groups = "drop"
      ) %>%
    group_by(pChar) %>%
    mutate(min.p_value_1 = min(p_value_1, na.rm = TRUE)) %>%
    ungroup() %>%
    # Clean and format
    filter(!is.na(p_value_1)) %>%
    mutate(
      
      # Set order of patient subgroups by greatest significance
      pChar = factor(
        pChar, 
        levels = unique(pChar[order(min.p_value_1)])
      )
    )
  }


# Standalone functions for level comparisons (factor levels within groups)

level_comparisons <- function(data, outcome, pChar_order = NULL) {
  # Helper function for safe t-tests
  perform_comparisons <- function(rates, values, outcome_col) {
    val_numeric <- as.numeric(values)
    
    safe_ttest <- function(group1_idx, group2_idx) {
      rates1 <- rates[val_numeric == group1_idx]
      rates2 <- rates[val_numeric == group2_idx]
      
      if(length(rates1) > 0 & length(rates2) > 0) {
        tryCatch(
          wilcox.test(rates1, rates2)$p.value,
          error = function(e) NA_real_
        )
      } else {
        NA_real_
      }
    }
    
    tibble(
      comparison = c(
        paste(levels(values)[1], "vs", levels(values)[2]),
        paste(levels(values)[3], "vs", levels(values)[4])
      ),
      p_value_2 = c(
        safe_ttest(1, 2),
        safe_ttest(3, 4)
      ),
      n_group1 = c(
        sum(val_numeric == 1),
        sum(val_numeric == 3)
      ),
      n_group2 = c(
        sum(val_numeric == 2),
        sum(val_numeric == 4)
      )
    )
  }
  
  result <- data %>%
    group_by(pChar, Group) %>%
    group_modify(~ perform_comparisons(.x[[outcome]], .x$value, outcome)) %>%
    # Clean and format
    filter(!is.na(p_value_2)) 
  
  # Apply pChar ordering if provided
  if (!is.null(pChar_order)) {
    result <- result %>%
      mutate(pChar = factor(pChar, levels = pChar_order))
  }
  
  return(result)
}


## Combine the two comparison functions 

all_comparisons <- function(data, outcome, K_threshold) {
  
  # Reformat input data-frame
  reformatted_data <- data %>% 
    mutate(
      K_level = ifelse(
        Serum_Potassium_mEq_L <= K_threshold, 
        "Yes", "No"
      )
    ) %>%
    pivot_longer(
      cols = c(K_level, Gender, Diabetes, Hypertension),
      names_to = "pChar",
      values_to = "value"
    ) %>%
    mutate(
      value = factor(value),
       pChar = ifelse(
        pChar == "K_level", 
        paste("Baseline K[+]", K_threshold, "mEq/mL or less"), 
        pChar
      )
      )
  
  # Run treatment comparison
  treatment_results <- treatment_comparisons(
    reformatted_data, 
    outcome
    )

  # Run level comparisons (with same pChar ordering as treatment_results)
  level_results <- level_comparisons(
    reformatted_data, 
    outcome, 
    pChar_order = levels(treatment_results$pChar)
    )

  # Join results and re-format data
  left_join(
    treatment_results,
    level_results,
    relationship = "many-to-many"
    ) %>%
  mutate(
    # Change Group to factor
    Group = factor(Group)
    )
  }

```


```{r chunk_3, fig.dim = c(10, 10)}
# Required: - R libraries (chunk libraries_and_data)
#           - HyKal_simData_rate (chunk 2)
#           - all_comparisons, halfviolin_facetPlot (chunk split_violin_plots_and_annotations)


## Plot distribution of treatment response rates and their differences between treatment groups

# Serum K[+] threshold that results in greatest significance when comparing response rates in SPS vs. SZC treated patients

K_threshold <- 5.3


# Generate a data-frame with test statistics for annotating the plot and sorting comparisons in stratified groups by significance

HyKal_simData_rate_p <-
  all_comparisons(HyKal_simData_rate, "Rate",
  K_threshold)

halfviolin_facetPlot(HyKal_simData_rate, "Rate", HyKal_simData_rate_p) +
  labs(
    title = paste(
    "Rate of K[+] change in patients treated with SPS or SZC, \nstratified by selected baseline characteristics"),
    x = NULL,
    y = bquote("Rate of serum K[+] " ~ "change (" ~ Delta ~ "mEq /L /Week)"),
    caption = "P-values: two-sided Wilcox test, no adjustment for multiple comparisons. \nBaseline characteristics in order of decreasing significance of SPS vs. SZC outcomes"
    )


```
<br>
<br>

### 4. Outcome 2: Time to first observation of normal serum K[+]
<br>

#### 4.1. Time to first observation of normal serum K[+] vs. numerical baseline patient characteristics
<br>

```{r chunk_4, fig.dim = c(10, 5)}
# Required: - R libraries, HyKal_simData (chunk libraries_and_data)
#           - quantBase_dotPlot (chunk 2)


## Select data for times when serum K[+] was in the normal range

HyKal_simData_normal <- 
  HyKal_simData %>%
    mutate(
      normal = ifelse(
        between(Serum_Potassium_mEq_L, min(normokalemia), max(normokalemia)), 
        Week, NA
        )
      ) %>% 
    na.omit %>% 
    select(!c(Time_Point, Serum_Potassium_mEq_L, normal) )
            

## Identify first week where serum K[+] levels were within normal range in each patient

HyKal_simData_normalFirst <- 
  HyKal_simData_normal %>% 
  group_by(Patient_ID) %>%
  # Use filter(row_number..) because slice(1) and slice_min produce wrong results in this context
  slice_min(., Week) %>%
  ungroup() %>%
  left_join(
    ., 
    HyKal_simData %>% filter(Time_Point == "Baseline") %>% 
      select(Patient_ID, Serum_Potassium_mEq_L) 
  ) %>% 
  rename("First_Week" = "Week") %>% 
  select(!Patient_ID)


## Plot first week within normal range vs. numerical baseline variables

HyKal_simData_normalFirst %>% 
quantBase_dotPlot(., "First_Week", 1.7, 2.5) +
  labs(
      title = "Time of first normal serum K[+] vs. baseline characteristics",
      x ="",
      y = bquote("Time of first normal serum K[+] (Week)"),
      caption = "Time of first normal serum K[+] does not appear to correlate with age, baseline estimated glomerular filtration rate (eGFR), or baseline serum K[+] levels."
    )


```
<br>

#### 4.2. Time to first observation of normal serum K[+] vs. selected categorical baseline patient characteristics
<br>
```{r chunk_5, fig.dim = c(10, 10)}
# Required: - R libraries (chunk libraries_and_data)
#           - HyKal_simData_normalFirst (chunk 4)
#           - all_comparisons, halfviolin_facetPlot (chunk split_violin_plots_and_annotations)


## Plot distribution of times to first normal serum K[+] and their differences between treatment groups

# Generate a data-frame with test statistics for annotating the plot and sorting comparisons in stratified groups by significance

HyKal_simData_normalFirst_p <-
  all_comparisons(HyKal_simData_normalFirst, "First_Week", K_threshold)


# Plot

halfviolin_facetPlot (HyKal_simData_normalFirst, "First_Week", HyKal_simData_normalFirst_p) +
  # Do not show negative scale for First_Week
  scale_y_continuous(breaks = seq(0, 8, 2)) +
  labs(
    title = paste(
    "Time of first normal serum K[+] in patients treated with SPS or SZC \nand stratified by selected baseline characteristics"),
    x = NULL,
    caption = "P-values: two-sided Wilcox test, no adjustment for multiple comparisons. \nBaseline characteristics in order of decreasing significance of SPS vs. SZC outcomes"
    ) 

```

<br>
<br>

### 5. Outcome 3: Total length of time a normal serum K[+] level was achieved
<br>

#### 5.1. Total length of time a normal serum K[+] was observed vs. numerical baseline patient characteristics
<br>

```{r chunk_6, fig.dim = c(10, 5)}
# - Required: R libraries, HyKal_simData (chunk libraries_and_data)
# normokalemia (chunk 1)
# HyKal_simData_normal (chunk 3)

## Plot numerical baseline variables vs. length of time serum K[+] level were within the normal range

HyKal_simData_normalPeriod <- 
  HyKal_simData_normal %>% 
  group_by(Patient_ID) %>%
  summarize(
    Period = max(Week) - min(Week) + 1, 
    .groups = "drop"
    ) %>% 
  left_join(
    ., 
    HyKal_simData %>% filter(Time_Point == "Baseline") 
    ) %>% 
  select(., !c(Patient_ID, Time_Point, Week))


## Plot first week within normal range vs. numerical baseline variables

HyKal_simData_normalPeriod %>%
quantBase_dotPlot(., "Period", 1.7, 2.5) +
    labs(
      title = "Length of time normal serum K[+] levels were observed vs. baseline characteristics",
      x ="",
      y = bquote("Total time at normal serum K[+] levels (Weeks)"),
      caption = "The length of time normal serum K[+] levels were observed does not appear to correlate with age, baseline estimated glomerular filtration rate (eGFR), \nor baseline serum K[+] levels."
    )

```
<br>

#### 5.2. Total length of time a normal serum K[+] was observed vs. selected categorical baseline patient characteristics
<br>

```{r chunk_7, fig.dim = c(10, 11)}
# Required: - R libraries (chunk libraries_and_data)
#           - HyKal_simData_normalPeriod (chunk 6)
#           - all_comparisons, halfviolin_facetPlot (chunk split_violin_plots_and_annotations)


## Plot distribution of total lengths of time with normal serum K[+], and their differences between treatment groups

# Serum K[+] threshold that results in the highest significance when comparing total lengths of time with normal serum K[+] in SPS vs. SZC treated patients

K_threshold <- 5.4

# Generate a data-frame with test statistics for annotating the plot 
# and sorting comparisons in stratified groups by significance

HyKal_simData_normalPeriod_p <- 
  all_comparisons(HyKal_simData_normalPeriod, "Period", K_threshold)

# Plot
halfviolin_facetPlot (HyKal_simData_normalPeriod, "Period", HyKal_simData_normalPeriod_p) +
  # Do not show negative scale for Period
  scale_y_continuous(breaks = seq(0, 8, 2)) +
  labs(
    title = paste(
    "Length of time normal serum K[+] levels were observed in patients treated with SPS or SZC \nand stratified by selected baseline characteristics"),
    x = NULL,
    y = "Total lenght of time (Weeks)",
    caption = "P-values: two-sided Wilcox test, no adjustment for multiple comparisons. \nBaseline characteristics in order of decreasing significance of SPS vs. SZC outcomes")
    
```
<br>
In comparison with the two other analyses, rate of serum K[+] change and first week of normal serum K[+] levels, the total length of time normokalemia was achieved showed the most significant differences across all patient subgroups.
<br>
<br>

### 6. Outcome 4: Patients who achieved normal serum K[+] levels at any time during treatment vs. patients who did not
<br>
The previous two analyses, first week and total time of normal serum K[+] levels, do not show the 9 patients in whom normokalemia was never observed at any time. Here, their baseline characteristics are compared with those of the treatment responders.
<br>

#### 6.1. Achievement of normokalemia at any timepoint vs. numerical baseline patient characteristics
<br>

```{r chunk_8, fig.dim = c(7.5, 7.5), fig.align = "center"}
# Required: R libraries, HyKal_simData (chunk libraries_and_data)

## Association of baseline variables with achieving normokalemia in at least one week of treatment


# Identify patients whose serum K[+] was outside the normal range throughout treatment

HyKal_simData_normoKal <- 
  HyKal_simData %>%
    # Add a column showing whether baseline levels were below or above K_threshold
    mutate(
        K_base = case_when(
            Serum_Potassium_mEq_L <= K_threshold & Time_Point == "Baseline" 
            ~ paste0(Group, ".K_low"), 
            Serum_Potassium_mEq_L > K_threshold & Time_Point == "Baseline" 
            ~ paste0(Group, ".K_high"),
            .default = NA_character_
        ) %>% factor()
    ) %>% 
    group_by(Patient_ID) %>%
    fill(K_base, .direction = "downup") %>% 
    # Add a column showing whether serum K[+] levels were normal at any time during treatment
    mutate(
        normoKal = ifelse(
            between(Serum_Potassium_mEq_L, min(normokalemia), max(normokalemia)), 
            Week, NA),
        normoKal = if (all(is.na(normoKal[-1]))) "Never" else "At least once"
    ) %>%
    ungroup() 


# Plot distribution of numerical baseline variable values for patients who achieved normokalemia and those who did not 

HyKal_simData_normoKal %>% 
  filter(Time_Point == "Baseline") %>%  
  mutate(
    normoKal = paste0(normoKal, "\n(", Group, ")"),
    normoKal = factor(normoKal, levels = rev(unique(normoKal)))
    ) %>%
  select(Group, Age, Baseline_eGFR, Serum_Potassium_mEq_L, normoKal) %>% 
  rename(
    "Age \n(years)" = Age,
    "Baseline eGFR \n(ml/min/1.73m^2)" = Baseline_eGFR,
    "Baseline serum K[+] \n(mEq/L)" = Serum_Potassium_mEq_L) %>% 
  pivot_longer(
    cols = !c(Group, normoKal), 
    names_to = "pChar"
    ) %>% 
  ggplot(
    aes(
      x = normoKal,
      y = value,
      fill = Group,
      color = Group
      )
    ) + 
  geom_violin( 
    width = 0.5,
    alpha = 0.4,
    color = "grey") +
  geom_boxplot(
      color = "black",
      alpha = 0,
      width = 0.3, 
      outlier.shape = NA) +
  geom_point(
    pch = 21,
    size = 3,
    position = 
      position_jitterdodge(
        dodge.width = 0.6, 
        jitter.width = 0.1
        ),
    color = "grey",
    alpha = 0.6
    ) +
    facet_grid(
      pChar ~ Group,
      switch = "y", 
      scales = "free", space = "free_x"
      ) +
  labs(
    x = "Normokalemia",
    y = "",
    title = "Association of quantitative baseline characteristics \nwith achievement of normokalemia at any timepoint during treatment",
    caption = "All patients treated with SZC had normal serum K[+] levels in at least one week of treatment. \nHigh eGFR and low K[+] at baseline could be risk factors for not achieving normokalemia at any time \nin patients treated with SPS."
    ) +
  theme_light () +
  theme(
    strip.background = element_blank(),
    strip.text.x = element_text(
      color = "black",
      vjust = 3,
      size = 12,
      ),
    strip.text.y = element_text(
      color = "black",
      size = 12
      ),
    strip.placement = "outside",
    plot.title = element_text(
      size = 14,
      hjust = 0.5,
      vjust = 5
      ),
    axis.text = element_text(size = 12),
    plot.caption = element_text(
      hjust = 0,
      vjust = -5
    ),
    plot.margin = unit(c(0.5,0.1,0.5,0), "cm"),
    legend.position = "none"
    ) 




```
<br>

#### 6.2. Achievement of normokalemia at any timepoint vs. categorical baseline patient characteristics
<br>

```{r, fig.dim = c(7.5, 7.5), fig.align = "center"}
# Required: - R libraries (chunk libraries_and_data)
#           - HyKal_simData_normoKal (chunk 8)


## Plot fraction of categorical baseline characteristics among who did and did not achieve normokalemia 

HyKal_simData_normoKal %>% 
    filter(Time_Point == "Baseline") %>%  
    mutate(normoKal = paste0(normoKal, "\n(", Group, ")")) %>%
    select(Group, Gender, Diabetes, Hypertension, normoKal) %>% 
    pivot_longer(
        cols = !c(Group, normoKal), 
        names_to = "pChar",
        values_to = "pChar_value"
    ) %>% 
    group_by(pChar, normoKal) %>%
    summarise(
        "Yes" = mean(pChar_value == "Yes") * 100,
        "No" = mean(pChar_value == "No") * 100,
        "Male" = mean(pChar_value == "Male") * 100,
        "Female" = mean(pChar_value == "Female") * 100,
        n = n()
    ) %>% ungroup() %>% 
    pivot_longer(
        cols = c(Yes, No, Male, Female),
        names_to = "pChar_value",
        values_to = "pChar_value_perc"
    ) %>% 
    mutate(
      Group = ifelse(grepl("SZC", normoKal), "SZC", "SPS"),
      Group_value = paste0(Group, "_", pChar_value),
      normoKal = paste0(normoKal, "\nn = ", n),
      normoKal = factor(normoKal, levels = rev(unique(normoKal)))
      ) %>% 
    filter(!pChar_value_perc == 0) %>% 
    ggplot(
      aes(
        x = normoKal,
        y = pChar_value_perc,
        fill = Group_value,
        group = Group_value
        )
      ) + 
    geom_col(
      width = 0.5
    ) +
    geom_text(
      aes(label = pChar_value),
      color = "white",
      fontface = "bold",
      size = 3.5,
                position = position_stack(vjust = 0.5)
            ) +
    scale_fill_manual(
      values = c(
        "#F8766D", "darkred", "#F8766D", "darkred",
        "#00BFC4", "darkcyan", "#00BFC4", "darkcyan"
        )
      ) +
    facet_grid(
      pChar ~ Group,
      switch = "y", 
      scales = "free_x", space = "free_x"
      ) +
    labs(
        x = "Normokalemia",
        y = "Fraction (%)",
        title = "Association of categorical baseline variables \nwith achievement of normokalemia at any timepoint during treatment",
        caption = "All patients treated with SZC had normal serum K[+] levels in at least one week of treatment."
    ) +
    theme_light () +
    theme(
        strip.background = element_blank(),
        strip.text.x = element_text(
            color = "black",
            vjust = 3,
            size = 12,
        ),
        strip.text.y = element_text(
            color = "black",
            size = 12
            ),
        strip.placement = "outside",
        text = element_text( size = 13), 
        plot.title = element_text(
            size = 14,
            hjust = 0.5,
            vjust = 5
        ),

        axis.text = element_text(size = 12),
        plot.caption = element_text(
            hjust = 0,
            vjust = -5
        ),
        plot.margin = unit(c(0.5,0.1,0.5,0), "cm"),
        legend.position = "none"
    ) 
```
<br>
<br>

### 7. References
<br>

1. Sodium zirconium cyclosilicate versus sodium polystyrene sulfonate for treatment of hyperkalemia in hemodialysis patients: a randomized clinical trial.
Elsayed MM, Abdelrahman MA, Sorour AM, Rizk IG, Hassab MAA. 
BMC Nephrol. 2025 May 6;26(1):227
https://doi.org/10.1186/s12882-025-04129-9

2. Chronic Hyperkaliemia in Chronic Kidney Disease: An Old Concern with New Answers.
Borrelli S, Matarazzo I, Lembo E, Peccarino L, Annoiato C, Scognamiglio MR, Foderini A, Ruotolo C, Franculli A, Capozzi F, Yavorskiy P, Merheb F, Provenzano M, La Manna G, De Nicola L, Minutolo R, Garofalo C.
Int J Mol Sci. 2022 Jun 7;23(12):6378
https://doi.org/10.3390/ijms23126378

3. https://www.ncbi.nlm.nih.gov/books/NBK470284/

4. Stephen L Seliger, Hyperkalemia in patients with chronic renal failure, Nephrology Dialysis Transplantation, Volume 34, Issue Supplement_3, December 2019, Pages iii12–iii18, https://doi.org/10.1093/ndt/gfz231


